# ì•± ì†Œê°œ
ì¼ìƒì˜ ì´ì•¼ê¸°ë¥¼ ê³µìœ í•˜ê³  ìì‹ ì˜ ê²Œì‹œê¸€ì„ ê´€ë¦¬í•˜ê³  ì¶”ì í•´ë³¼ ìˆ˜ ìˆëŠ” ì•±ì…ë‹ˆë‹¤. 
- ê²Œì‹œê¸€ ì‘ì„± ê¸°ëŠ¥(ì´ë¯¸ì§€ í¬í•¨)
- ê²Œì‹œê¸€ ì¢‹ì•„ìš”
- ê²Œì‹œê¸€ í•´ì‹œíƒœê·¸ ê¸°ëŠ¥
- ìœ ì € íŒ”ë¡œìš° ê¸°ëŠ¥
- í”„ë¡œí•„ ê´€ë¦¬ ê¸°ëŠ¥

# ğŸ—“ï¸ í”„ë¡œì íŠ¸ ê¸°ê°„
2023/11/17 ~ 2023/12/17

# ğŸ‘¥ í”„ë¡œì íŠ¸ ì°¸ì—¬ ì¸ì›
1ëª…(ê°œì¸)

# ğŸ› ï¸ ì‚¬ìš©ëœ í”„ë ˆì„ì›Œí¬, ë¼ì´ë¸ŒëŸ¬ë¦¬, ë””ìì¸ íŒ¨í„´
- MVVM
- UIKit
- RxSwift
- RxDatasource
- Snapkit
- Kingfisher
- Tabman
- IQKeyboardManager

# â­ï¸ ì¤‘ìš” ê¸°ëŠ¥
<p align="center" width="100%">
    <img src="https://github.com/SSABOODA/PictureFlow/assets/69753846/44ad5fae-4164-4b99-8084-61b3e64155a9" width="100%">
    <img src="https://github.com/SSABOODA/PictureFlow/assets/69753846/5916df0b-e93d-4552-9313-19a652204fd9" width="100%">
</p>

# ğŸ” êµ¬í˜„ ê¸°ëŠ¥
- íšŒì›ê°€ì…, ë¡œê·¸ì¸ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì˜€ê³  ë¡œê·¸ì¸ ê°™ì€ ê²½ìš° JWT Tokenê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤. `Refresh Token` ê´€ë¦¬ ë˜í•œ `Alamofire`ì˜ `Interceptor`ë¥¼ í†µí•´ `Refresh Token`ì„ ê°±ì‹ í•˜ì—¬ í˜„ì¬ ìœ ì €ì˜ ë¡œê·¸ì¸ ìƒíƒœë¥¼ ìœ ì§€í•˜ê±°ë‚˜ `Refresh Token`ì´ ë§Œë£Œë˜ì—ˆë‹¤ë©´ ì¬ë¡œê·¸ì¸ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
- ê²Œì‹œê¸€ì„ ê´€ë¦¬í•˜ëŠ” í”¼ë“œì—ì„œëŠ” RxSwift ê¸°ë°˜ì˜ UITableViewë¥¼ í™œìš©í•´ì„œ êµ¬ì„±í•˜ì˜€ê³  ì…€ì•ˆì— ì´ë¯¸ì§€ ë°ì´í„° ë˜í•œ dataSetì„ tableViewì˜ cellì„ êµ¬ì„±í•  ë•Œ Observableë¡œ Streamì„ ë°©ì¶œí•˜ì—¬ Rx CollectionViewë¡œ êµ¬ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.
- ê²Œì‹œê¸€ ëª©ë¡ì—ì„œ Rxê¸°ë°˜ì˜ `PullToRefresh`ë¥¼ êµ¬í˜„í•´ ë°ì´í„°ë¥¼ Reloadí•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ê³ , `Cursor ê¸°ë°˜ Pagination`ì„ `Rx PrefetchRows`ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
- ê²Œì‹œê¸€ ìƒì„¸ Viewì—ì„œëŠ” `RxDataSource`ë¥¼ í™œìš©í•´ Sectionì˜ HeaderViewì™€ CollectionViewë¥¼ í†µí•´ ê²Œì‹œê¸€ ì •ë³´ ì•„ë˜ì— ëŒ“ê¸€ ì •ë³´ë¥¼ í‘œí˜„í•˜ë„ë¡í•˜ì˜€ìŠµë‹ˆë‹¤.
- ê²Œì‹œê¸€ì´ë‚˜ ì•± ì „ì²´ì˜ ì´ë¯¸ì§€ë“¤ì€ í™•ëŒ€í•˜ì—¬ í™•ì¸í• ìˆ˜ ìˆë„ë¡ FullScreen Viewë¥¼ Customí•˜ì—¬ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
- í•´ì‹œíƒœê·¸ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ UITextViewì˜ RxSwiftë¥¼ Custom í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ì˜€ê³  UITapGestureRecognizer í´ë˜ìŠ¤ë¥¼ Customí•˜ì—¬ í•´ì‹œíƒœê·¸ ë‹¨ì–´ì— ëŒ€í•´ Linkì²˜ëŸ¼ Clickì´ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
- í•´ì‹œíƒœê·¸ë¥¼ ì‚¬ìš©ìê°€ ì‰½ê²Œ ì‘ì„±í•˜ë„ë¡ UITextViewë¥¼ Customí•˜ì˜€ê³  ì •ê·œì‹ì„ í†µí•´ `#`ì„ ê¸°ì¤€ìœ¼ë¡œ ì‚¬ìš©ìê°€ ì…ë ¥í•˜ëŠ” ë‹¨ì–´ì— ëŒ€í•´ì„œëŠ” ëŒ€ë¹„ ìƒ‰ìƒ ì ìš©í•˜ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.
- ê²Œì‹œê¸€ ì‘ì„± Viewì—ì„œëŠ” UITextViewì˜ `sizeThatFits` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ ì¤„ë°”ê¿ˆì„ í•˜ë©´ Viewê°€ ëŠ˜ì–´ë‚˜ë„ë¡ íš¨ê³¼ë¥¼ ì£¼ì—ˆìŠµë‹ˆë‹¤. 
- ê²Œì‹œê¸€ ì‘ì„±ì—ì„œ `PHPickerViewController`ë¥¼ í†µí•´ ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë„ë¡ í•˜ì˜€ê³  CollectionViewë¥¼ í™œìš©í•´ ì„ íƒí•œ ì´ë¯¸ì§€ë¥¼ ë‚˜íƒ€ë‚´ê³  ì‚­ì œí•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.
- í”„ë¡œí•„ì—ì„œëŠ” `TabMan`, `Pageboy` ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•´ ë‚´ê°€ ì‘ì„±í•œ ê²Œì‹œê¸€, íŒ”ë¡œì›Œ, íŒ”ë¡œì‰ ëª©ë¡ì„ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
  
# ğŸ“– í”„ë¡œì íŠ¸ ê¸°íš ë° ê¸°ë¡
---

# ğŸ”¥ ì´ìŠˆ
## 1. tableHeaderView dynamic height
ê²Œì‹œê¸€ì˜ ìƒì„¸í™”ë©´ View ë°‘ì— í•´ë‹¹ ê²Œì‹œê¸€ì— ëŒ€í•œ ëŒ“ê¸€ë“¤ì„ í‘œì‹œí•  ìˆ˜ ìˆë„ë¡ ëŒ“ê¸€ ì•„ì´í…œë“¤ì€ TableViewë¡œ í‘œì‹œí•˜ê³  TableViewìœ„ì—ëŠ” ê²Œì‹œê¸€ ìƒì„¸ Viewê°€ ìœ„ì¹˜í•˜ëŠ” Viewë¥¼ êµ¬ì„±í•  í•„ìš”ê°€ ìˆì—ˆìŠµë‹ˆë‹¤.

ìƒë‹¨ ê²Œì‹œê¸€ ì •ë³´ Viewì™€ í•¨ê»˜ ëŒ“ê¸€ì„ êµ¬ì„±í•˜ë˜ Tableview ë˜í•œ ê°™ì´ Scrollë˜ê¸¸ ì›í–ˆê¸° ë•Œë¬¸ì— HeaderViewë‚˜ ScrollViewë¡œ êµ¬ì„±ì„ í•´ì•¼í–ˆìŠµë‹ˆë‹¤. 

### ë¬¸ì œ ìƒí™©
ê·¸ë ‡ë‹¤ë©´ UITableViewê°€ ê°€ì§€ê³  ìˆëŠ” tableHeaderView ì†ì„±ì— UIViewë¥¼ ë„£ì–´ì¤„ ìˆ˜ ìˆëŠ” ì†ì„±ì„ ì‚¬ìš©í–ˆì—ˆì„ ë•Œ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê²Œì‹œê¸€ì˜ ì»¨í…ì¸  ì–‘ì— ë”°ë¼(Content, Image ì—¬ë¶€ ë“±â€¦) ìœ ë™ì ì¸ ë†’ì´ë¥¼ ì¡ì•„ì¤¬ì–´ì•¼í–ˆëŠ”ë° tableHeaderViewì—ì„œëŠ” ìœ ë™ì ì¸ ë†’ì´ë¥¼ ì¡ê¸°ê°€ ì•Šì•˜ìŠµë‹ˆë‹¤. 

ë¬¼ë¡  êµ¬ê¸€ë§ì„ í†µí•´ ë‹¤ìŒê³¼ ê°™ì´ ìœ ë™ì ì¸ ë†’ì´ë¥¼ ë‹¤ì‹œ ê³„ì‚°í•´ì„œ ì¡ì•„ì£¼ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•´ë´¤ì§€ë§Œ UILabelê°™ì€ ê²½ìš° ë†’ì´ë¥¼ ì»¨í…ì¸ ì˜ ì–‘ì— ë§ê²Œ ì¡ì•„ ì£¼ì§€ ì•Šì•„ì„œ ë”± ì•Œë§ê²Œ ë“¤ì–´ê°€ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 

ìš°ì„  ì™œ êµ³ì´ ê°€ë³€ ë†’ì´ì˜ HeaderViewë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ Layoutì¡ê¸° ê¹Œë‹¤ë¡œìš´ tableHeaderViewë¥¼ ì‚¬ìš©í•˜ë ¤ í–ˆë‚˜? ì— ëŒ€í•œ ë‹µë³€ì€ ê²Œì‹œê¸€ ìƒì„¸ Viewì—ëŠ” ì„¹ì…˜ì´ ì—†ê¸° ë•Œë¬¸ì— tableHeaderViewë§Œìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•´ ë…¸ë ¥í–ˆë˜ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

### **ë¬¸ì œ í•´ê²°**
1. Layout ì¡ê¸°
ìš°ì„  ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ ì‹œë„í–ˆë˜ ë°©ë²•ì€ tableHeaderView ìì²´ë¥¼ Viewì—ì„œ í™•ì¸í•´ì•¼í–ˆê³ , Build ê²°ê³¼ tableHeaderViewê°€ ë³´ì´ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ìš°ì„  `Debug View Hierarchy` ë¥¼ í†µí•´ í™•ì¸ ê²°ê³¼ headerViewì˜ Layoutì´ ì¡íˆì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì‹œë®¬ë ˆì´í„°ì—ì„œ ë³´ì§€ì§€ ì•Šì•˜ë˜ ê²ë‹ˆë‹¤.

ê·¸ë˜ì„œ ìš°ì„  Layoutì„ ì¡ì•„ì¤˜ì•¼ê² ë‹¤ëŠ” ìƒê°ì„ í–ˆê³  ë‹¤ìŒê³¼ ê°™ì´ Layoutì„ ì¡ì•˜ìŠµë‹ˆë‹¤.
```swift
headerView.snp.makeConstraints { make in
    make.width.equalTo(view.bounds.width)
    make.height.equalTo(150)
}
```

Widthê°™ì€ ê²½ìš°ëŠ” ê¸°ê¸° Screenì— ê½‰ì°¨ê²Œ êµ¬ì„±ì„ í–ˆê³  ë†’ì´ëŠ” ìš°ì„  ê³ ì •ìœ¼ë¡œ ì¡ê³  Buildí•˜ì˜€ìŠµë‹ˆë‹¤.
ê·¸ ê²°ê³¼ Viewì—ëŠ” ì˜ í‘œì‹œë˜ì—ˆì§€ë§Œ TableView Cellê³¼ ê²¹ì³ì„œ Viewì— í‘œì‹œë˜ëŠ” ìƒí™©ì´ ë˜ì—ˆìŠµë‹ˆë‹¤. 

í•œì°¸ì„ ì‹œë„í•œ ê²°ê³¼ ì• ì´ˆì— Frameìœ¼ë¡œ ë†’ì´ë¥¼ ì¡ì•„ì£¼ëŠ” ë°©ë²•ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
```swift
headerView.frame = CGRect(x: 0, y: 0, width: view.bounds.width, height: 150)
```

frameì„ ì¡ì•„ì¤¬ë”ë‹ˆ cellê³¼ ê²¹ì¹˜ì§€ ì•Šê³  Viewì— ì˜ ë‚˜íƒ€ë‚˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ ì¸ì œ header viewì˜ ì»¨í…ì¸ ì— ë”°ë¼ ìœ ë™ì ìœ¼ë¡œ ë†’ì´ë¥¼ ì¡ì•„ë³´ë ¤ê³  ì‹œë„í–ˆìŠµë‹ˆë‹¤. ê·¸ëŸ´ë ¤ë©´ heightë¥¼ ê³ ì •ì ìœ¼ë¡œ ì£¼ë©´ ì•ˆë˜ì—ˆê¸°ì— ë˜ í•œë²ˆì— ë¬¸ì œì— ë¶€ë”ªíˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

ìš°ì„  ê°€ë³€ ë†’ì´ë¥¼ ì§€ì •í•˜ê¸° ìœ„í•´ ë§ì€ ë°©ë²•ì„ ì°¾ë˜ ì¤‘ ë‹¤ìŒ ì½”ë“œë¥¼ í™œìš©í•´ headerViewì˜ ë†’ì´ë¥¼ ê°€ë³€ì ìœ¼ë¡œ ì¡ì•„ì¤„ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? í•´ì„œ ì ìš©í•´ë³´ê²Œë˜ì—ˆìŠµë‹ˆë‹¤.

```swift
func sizeHeaderToFit() {
    if let headerView = mainView.tableView.tableHeaderView {
        headerView.setNeedsLayout()
        headerView.layoutIfNeeded()

        let height = headerView.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
        var newFrame = headerView.frame
        if height != newFrame.size.height {
            newFrame.size.height = height
            headerView.frame = newFrame

            mainView.tableView.tableHeaderView = headerView
        }
    }
}
```

í•˜ì§€ë§Œ ìœ„ ì½”ë“œì¡°ì°¨ Labelì˜ ë†’ì´ê°€ ì§€ì •ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ headerViewëŠ” ì‚¬ë¼ì§€ê³  Labelë§Œ ë‚¨ê²Œ ë˜ì–´ ì›í•˜ëŠ” Viewì˜ í˜•íƒœê°€ ë‚˜ì˜¤ì§ˆ ì•Šì•˜ìŠµë‹ˆë‹¤. 
 
ë§ˆì§€ë§‰ìœ¼ë¡œ ì‹œë„í–ˆë˜ ë°©ë²•ì€ ê°€ë³€ì ì¸ ì»¨í…ì¸ ì˜ ë†’ì´ë¥¼ ì¼ì¼ì´ ê³„ì‚°í•˜ì—¬ `layoutIfNeeded` ë©”ì„œë“œë¥¼ í™œìš©í•´ HeaderViewì˜ ë†’ì´ë¥¼ ë‹¤ì‹œ ì¡ì•„ì£¼ëŠ” ë°©ë²•ì„ í™œìš©í–ˆì—ˆìŠµë‹ˆë‹¤.

```swift
class HeaderView: UIView {
    let label = {
        let lb = UILabel()
        lb.numberOfLines = 0
        return lb
    }()
    
    let button = {
        let bt = UIButton()
        bt.setTitle("í´ë¦­", for: .normal)
        bt.backgroundColor = .darkGray
        return bt
    }()
    
    var contentHeight: CGFloat {
        let height = 
        label.bounds.height +
        button.bounds.height +
        labelTopDistance +
        labelToButtonBetweenDistance +
	10.0
        return height
    }
    
    let labelTopDistance = 5.0
    let labelToButtonBetweenDistance = 10.0

    override init(frame: CGRect) {
        super.init(frame: frame)
        layout()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func layout() {
        addSubview(label)
        label.snp.makeConstraints { make in
            make.top.horizontalEdges.equalToSuperview().inset(labelTopDistance)
        }
        
        addSubview(button)
        button.snp.makeConstraints { make in
            make.top.equalTo(label.snp.bottom).offset(labelToButtonBetweenDistance)
            make.horizontalEdges.equalToSuperview().inset(5)
        }
    }
}
```

ìœ„ì™€ ê°™ì´ ì¼ì¼íˆ ëª¨ë“  View ê°ì²´ì˜ ë†’ì´ì™€ topê³¼ bottom ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ëª¨ë‘ ê³„ì‚°í•˜ëŠ” `contentHeight` ë¼ëŠ” ê³„ì‚°ì†ì„±ì„ í†µí•´ ê³„ì‚°í•œ ë’¤ ViewControllerì—ì„œ Layoutì„ ì¡ì„ ë•Œ Frameì— ëŒ€ì…í•´ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

```swift
class TableHeaderViewController: UIViewController {
    private func updateHederViewHeight() {
        let calculatedHeight: CGFloat = headerView.contentHeight
        print("calculatedHeight: \(calculatedHeight)")
        headerView.frame = CGRect(x: 0, y: 0, width: view.bounds.width, height: calculatedHeight)
        tableView.tableHeaderView = headerView
    }
}
```

ì´ë ‡ê²Œ ë˜ë©´ í•´ë‹¹ ì»¨í…ì¸ ì— ë”°ë¼ ìœ ë™ì ì¸ ë†’ì´ë¥¼ ê°€ì§€ëŠ” tableHeaderViewë¥¼ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ ê²°ë¡ ì ìœ¼ë¡œ ëª¨ë“  ê°ì²´ì˜ ë†’ì´ë¥¼ ê³„ì‚°í•´ì„œ ë‹¤ì‹œ Layoutì„ ê·¸ë¦°ë‹¤ëŠ” ë°©ë²• ìì²´ê°€ ë§ˆìŒì— ë“¤ì§€ëŠ” ì•Šì•„ì„œ ê²°êµ­ `RxDataSource`ë¥¼ ì‚¬ìš©í–ˆê³  `configureSupplementaryView`ì— HeaderViewë¥¼ ê·¸ë ¤ì„œ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

## 2. ê²Œì‹œê¸€ ì»¨í…ì¸ ì—ì„œ hash tag í´ë¦­ì‹œ ë‹¤ë¥¸ View ì´ë™
### ë¬¸ì œ ìƒí™©
ê²Œì‹œê¸€ì˜ í…ìŠ¤íŠ¸ ì»¨í…ì¸ ì—ì„œ í•´ì‹œíƒœê·¸ë¥¼ ì„¤ì •í•˜ë©´ í•´ë‹¹ í•´ì‹œ íƒœê·¸ëŠ” ë‹¤ë¥¸ í…ìŠ¤íŠ¸ì™€ ìƒ‰ìƒì´ ëŒ€ë¹„ë˜ë„ë¡ ì„¤ì •í•˜ê³  í•´ë‹¹ í•´ì‹œíƒœê·¸ëŠ” í´ë¦­ì‹œ linkê°€ ë˜ë„ë¡ ì„¤ì •í•´ì•¼í–ˆìŠµë‹ˆë‹¤.

### ë¬¸ì œ í•´ê²°
1. ìš°ì„  í…ìŠ¤íŠ¸ê°€ linkê°€ ë  ìˆ˜ ìˆë„ë¡ ì„¤ì •í•˜ë ¤ë©´ ì–´ë–¤ ë°©ë²•ì´ ìˆëŠ”ì§€ ê³ ë¯¼í•˜ë˜ ì¤‘ ìŠ¤í† ë¦¬ë³´ë“œë¡œ UITextViewë¥¼ êµ¬ì„±í•  ë•Œ attributesë¥¼ ì„¤ì •í•  ë•Œ `data detectors` ì— linkë¥¼ ì²´í¬í•˜ë©´ í…ìŠ¤íŠ¸ ì•ˆì— urlì´ ìˆìœ¼ë©´ ìë™ìœ¼ë¡œ ëŒ€ë¹„ ìƒ‰ìƒê³¼ í•¨ê»˜ í´ë¦­ ì‹œ í•´ë‹¹ urlìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆì—ˆë˜ ê¸°ëŠ¥ì„ í™œìš©í•˜ë©´ íŠ¹ì • ë‹¨ì–´ì—ë„ link ê¸°ëŠ¥ì„ ë„£ì„ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? í•´ì„œ í•´ë‹¹ ì ‘ê·¼í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

ë¬¸ìì—´ì˜ íŠ¹ì • ë¬¸ìì˜ Styleì„ ë³€ê²½í•  ìˆ˜ ìˆëŠ” í´ë˜ìŠ¤ì¸ `NSMutableAttributedString` ì„ í™œìš©í•´ í•´ì‹œíƒœê·¸ì˜ íŠ¹ì • ë¬¸ìì˜ Styleê³¼ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆê² ë‹¤ë¼ê³  ì ‘ê·¼í–ˆìŠµë‹ˆë‹¤.

`NSMutableAttributedString`ì€ `NSAttributedString` ë¥¼ ìƒì†ë°›ê³  ìˆìœ¼ë©° `NSAttributedString`ì— ì†í•œ íŠ¹ì • ë²”ìœ„ì— ë¬¸ìì˜ ì‹œê°ì  ìŠ¤íƒ€ì¼, í•˜ì´í¼ë§í¬ ë˜ëŠ” ì ‘ê·¼ì„± ë°ì´í„°ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì´ë¼ê³  ë‚˜ì™€ìˆìŠµë‹ˆë‹¤.

```swift
final class HashtagTextView: UITextView {
    var hashtagArr: [String]?
    
    func resolveHashTags() {
        self.isEditable = false
        self.isSelectable = true
        
        let nsText: NSString = self.text as NSString
        let attrString = NSMutableAttributedString(string: nsText as String)
        let hashtagDetector = try? NSRegularExpression(
            pattern: "#(\\w+)",
            options: NSRegularExpression.Options.caseInsensitive
        )
        
        let results = hashtagDetector?.matches(
            in: self.text,
            options: NSRegularExpression.MatchingOptions.withoutAnchoringBounds,
            range: NSMakeRange(0, self.text.utf16.count)
        )
        
        let hashtagAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.boldSystemFont(ofSize: 18),
            .foregroundColor: UIColor.systemBlue
        ]
        
        let regularTextAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 18),
            .foregroundColor: UIColor(resource: .text)
        ]
        
        // ê¸°ì¡´ ì†ì„± ì´ˆê¸°í™”
        attrString.removeAttribute(.foregroundColor, range: NSRange(location: 0, length: attrString.length))
        attrString.addAttributes(regularTextAttributes, range: NSRange(location: 0, length: attrString.length))

        hashtagArr = results?.map { (self.text as NSString).substring(with: $0.range(at: 1)) }
        if hashtagArr?.count != 0 {
            var i = 0
            for var word in hashtagArr! {
                word = "#" + word
                if word.hasPrefix("#") {
                    let matchRange:NSRange = nsText.range(of: word as String, options: [.caseInsensitive, .backwards])
                                                                
                    attrString.addAttribute(NSAttributedString.Key.link, value: "\(i)", range: matchRange)
                    attrString.addAttributes(hashtagAttributes, range: matchRange)
                    i += 1
                }
            }
        }

        self.attributedText = attrString
    }
}
```

```swift
contentTextView.text = elements.content
contentTextView.hashtagArr = elements.hashTags
contentTextView.resolveHashTags()
```

`NSMutableAttributedString` ë¥¼ í†µí•´ í•´ë‹¹ ë¬¸ìì—´ì— í•´ì‹œíƒœê·¸ë¥¼ â€˜#â€™ ê³¼ ë¶™ì–´ìˆëŠ” ë¬¸ìë¥¼ ì¶”ì¶œí•˜ëŠ” ì •ê·œì‹ì„ ì‚¬ìš©í•˜ì˜€ê³  ì¶”ì¶œí•œ ë¬¸ìë“¤ì˜ ì†ì„±ë§Œ link ì†ì„±ê³¼ ìƒ‰ìƒ, font í¬ê¸°ë¥¼ ë³€ê²½ì‹œì¼œì£¼ì—ˆìŠµë‹ˆë‹¤.

## 3. Rxswift button tap stream error handling
### ë¬¸ì œ ìƒí™©
í•´ë‹¹ ë¬¸ì œëŠ” íšŒì›ê°€ì… ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ë˜ ì¤‘ ë°œìƒí•œ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤. íšŒì›ê°€ì… ì‹œ í•„ìš”í•œ ì •ë³´(ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸, ë‹‰ë„¤ì„..) ë“±ì„ ë°›ê³  ë§ˆì§€ë§‰ìœ¼ë¡œ ë¡œê·¸ì¸ ë²„íŠ¼ì„ tap í•œë‹¤ë©´ í•´ë‹¹ CombineLatestë¡œ ë¬¶ì–´ë†“ì•˜ë˜ ë°ì´í„°ë“¤ê³¼ í•¨ê»˜ Streamì„ ì‹œì‘í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ í†µì‹ í•˜ëŠ” Rx ë¡œì§ì„ êµ¬ì„±í•˜ì˜€ìŠµë‹ˆë‹¤. ê·¸ ê³¼ì •ì—ì„œ flatMapì„ í†µí•´ ë¯¸ë¦¬ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•´ë†“ì•˜ë˜ NetWork í´ë˜ìŠ¤ ì•ˆì˜ ë¡œê·¸ì¸ API í†µì‹  ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì˜€ìŠµë‹ˆë‹¤.

- Network.swift
```swift
func requestObservableConvertible<T: Decodable> (
    type: T.Type,
    router: Router
) -> Observable<T> {
    return Observable.create { emitter -> Disposable in
	let request = AF.request(
	    router,
	    interceptor: AuthManager()
	)
            .validate()
            .responseDecodable(of: T.self) { response in
		switch response.result {
		case .success(let success):
		    emitter.onNext(success)
                    emitter.onCompleted()
		case .failure(let failure):
                    emitter.onError(failure)
		}
	    }
	return Disposables.create() {
	    request.cancel()
	}
    }
}
```

- loginViewModel.swift
```swift
input.loginButtonTap
    .withLatestFrom(loginModelObservable)
    .flatMap {
        Network.shared.fetch(
            type: LoginResponse.self,
            router: .login(model: $0)
        )
    }
    .subscribe(with: self) { owner, data in
	print("data: \(data)")
    } onError: { owner, error in
	print("Rx login onError")
    } onCompleted: { owner in
	print("Rx login onCompleted")
    } onDisposed: { owner in
	print("Rx login onDisposed")
    }
    .disposed(by: disposeBag)
```

ë¡œê·¸ì¸ API í†µì‹ ì„ ì§„í–‰í–ˆê³  ë¡œê·¸ì¸API ëª…ì„¸ì„œì˜ ìš”êµ¬ì‚¬í•­ì— ë§ê²Œ ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ì§€ ì•Šì•„ ì—ëŸ¬ê°€ ë‚˜ëŠ” ìƒí™©ì´ ìƒê²¼ìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œ ë¡œê·¸ì¸ buttonì˜ rx tap streamì€ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì˜ ì—ëŸ¬ì™€ í•¨ê»˜ onError ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ë©´ì„œ disposeë˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

```
Rx login onError
Rx login onDisposed
```

ì´ë ‡ê²Œ ë˜ë©´ ì—¬ê¸°ì„œë¶€í„° ë¬¸ì œê°€ ë°œìƒí•©ë‹ˆë‹¤. ìœ ì €ëŠ” ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆë”ë¼ë„ ë¡œê·¸ì¸ ì •ë³´ë¥¼ ìˆ˜ì •í•œë‹¤ë©´ ë‹¤ì‹œ ë²„íŠ¼ì„ ëˆ„ë¥¼ìˆ˜ ìˆì–´ì•¼í•˜ì§€ë§Œ ì´ë¯¸ ë¡œê·¸ì¸ ë²„íŠ¼ì˜ streamì€ disposeëœ ìƒíƒœì´ê¸° ë•Œë¬¸ì— ì•„ë¬´ë¦¬ ì •ë³´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ìˆ˜ì •í•œë‹¤ í•˜ë”ë¼ë„ ë²„íŠ¼ì€ ë” ì´ìƒ ë™ì‘í•˜ì§€ ì•Šê²Œ ë©ë‹ˆë‹¤.
### ë¬¸ì œ í•´ê²°
1. ì²«ë²ˆì§¸ë¡œ ì‹œë„í–ˆë˜ ë°©ë²•ì€ `catchAndReturn`ìœ¼ë¡œ ì—ëŸ¬ ë°œìƒì‹œ ê¸°ë³¸ê°’ì„ returní•¨ìœ¼ë¡œì¨ `onError` ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ì§€ ëª»í•˜ê²Œ í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.
```swift
.flatMap {
    Network.shared.fetch(
	type: LoginResponse.self,
	router: .login(model: $0)
    )
    .catchAndReturn(LoginResponse(_id: "", token: "", refreshToken: ""))
}
```

í•˜ì§€ë§Œ ì´ ë°©ë²•ì€ ì—ëŸ¬ ë°œìƒ ì‹œ ë¯¸ë¦¬ ì„¸íŒ…í•´ë‘” ê¸°ë³¸ ê°’ë§Œ ë°©ì¶œí•˜ê¸° ë•Œë¬¸ì— ì„œë²„ì—ì„œ ì˜¤ëŠ” ë‹¤ì–‘í•œ error handlingí•˜ê¸° ë¶€ì í•©í•˜ë‹¤ëŠ” ê²ƒì„ ê¹¨ë‹¬ì•˜ìŠµë‹ˆë‹¤.

ì§€ê¸ˆ í•´ê²°í•´ì•¼í•˜ëŠ” ë¶€ë¶„ì€ streamì´ ëŠê¸°ì§€ ì•Šìœ¼ë©´ì„œ ì„œë²„ì˜ ì—ëŸ¬ê¹Œì§€ í•¸ë“¤ë§ í•  ìˆ˜ ìˆì–´ì•¼í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
2. ë‘ë²ˆì§¸ ë°©ë²•ì€ `Single` traitsë¥¼ ì‚¬ìš©í•˜ì—¬ `fetch` ë©”ì„œë“œì—ì„œ ë°©ì¶œí•˜ëŠ” ë‹¨ì¼ Observable ì´ë²¤íŠ¸ë¥¼ ë˜í•‘í•˜ì—¬ errorë¥¼ ë°©ì¶œí•˜ì§€ ì•Šê³  í•´ë‹¹ ë²„íŠ¼ streamì— ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

- Network.swift
```swift
func fetchSingle<T: Decodable> (
    type: T.Type,
    router: Router
) -> Single<Result<T, AFError>> {
    return Single.create { emitter -> Disposable in
	let request = AF.request(
	    router,
	    interceptor: AuthManager()
	)
	    .validate()
            .responseDecodable(of: T.self) { response in
		switch response.result {
		case .success(let success):
			emitter(.success(.success(success)))
		case .failure(let failure):
			emitter(.success(.failure(failure)))
		}
	    }
	return Disposables.create() {
		request.cancel()
	}
    }
}
```

- loginViewModel.swift
```swift
input.loginButtonTap
    .withLatestFrom(loginModelObservable)
    .flatMap {
	Network.shared.fetchSingle(
	    type: LoginResponse.self,
	    router: .login(model: $0)
	)
    }
    .subscribe(with: self) { owner, result in
	switch result {
	    case .success(let data):
		print(data)
	    case .failure(let error):
		print(error)
	}
    } onError: { owner, error in
	print("Rx login onError")
    } onCompleted: { owner in
	print("Rx login onCompleted")
    } onDisposed: { owner in
	print("Rx login onDisposed")
    }
    .disposed(by: disposeBag)
```

`flatMap` ì—ì„œ ë„¤íŠ¸ì›Œí¬ í†µì‹ í•˜ëŠ” ë©”ì„œë“œì—ì„œ Single Traiteì´ Observableì„ ë°©ì¶œí•  ë•Œ ì—ëŸ¬ì‹œì—ë„ Success caseì— í•œë²ˆ ë˜í•‘í•œ ë’¤ ë°©ì¶œí•˜ê²Œ ë˜ë©´ `flatMap` Operatorë¥¼ í†µí•´ ìƒˆë¡œìš´ Observableì„ ë°©ì¶œí•˜ê²Œ ë  ë•Œ Result Typeê³¼ Single Traitsì´ ë˜í•‘ëœ ìƒíƒœë¡œ ë°©ì¶œë˜ê¸° ë•Œë¬¸ì— subscribeì—ì„œ switch ë¬¸ì„ í†µí•´ ë˜í•‘ì„ í•´ì œí•˜ê³  ì„œë²„ì—ì„œ ë°›ì•„ì˜¨ ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ë©´ ë©ë‹ˆë‹¤. ì´ë ‡ê²Œ ë˜ë©´ ë¡œê·¸ì¸ buttonì˜ streamì€ ì‚´ì•„ìˆê²Œ ë˜ë©° ì—ëŸ¬ í•¸ë“¤ë§ê¹Œì§€ ê°€ëŠ¥í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. 

button tap streamì—ì„œ í•œë²ˆ ë” ë˜í•‘ì„ í•´ì œí•˜ê¸° ë•Œë¬¸ì— switch caseë¥¼ í•œë²ˆ ë” ì‚¬ìš©í•˜ê²Œ ë˜ëŠ” ë‹¨ì ì´ ìˆê¸´ í•˜ì§€ë§Œ ì›í•˜ëŠ” ë°©í–¥ìœ¼ë¡œ ê¸°ëŠ¥í•  ìˆ˜ ìˆê²Œ ë˜ì–´ ë¬¸ì œí•´ê²°ì„ í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.
